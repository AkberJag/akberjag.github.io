import{_ as e,c as s,a1 as a,o}from"./chunks/framework.BAjNsQ49.js";const n="/docs/assets/TestingPyramid.BbR975iB.png",y=JSON.parse('{"title":"ðŸ”º The Testing Pyramid","description":"","frontmatter":{},"headers":[],"relativePath":"python/TDD/the_testing_pyramid.md","filePath":"python/TDD/the_testing_pyramid.md","lastUpdated":1741491859000}'),r={name:"python/TDD/the_testing_pyramid.md"};function i(l,t,h,d,g,p){return o(),s("div",null,t[0]||(t[0]=[a('<h1 id="ðŸ”º-the-testing-pyramid" tabindex="-1">ðŸ”º The Testing Pyramid <a class="header-anchor" href="#ðŸ”º-the-testing-pyramid" aria-label="Permalink to &quot;ðŸ”º The Testing Pyramid&quot;">â€‹</a></h1><p>The <strong>Testing Pyramid</strong> is a conceptual framework that helps developers understand the different types of tests they should write and how to balance them. It emphasizes the importance of having a solid foundation of unit tests, supported by integration tests, and a smaller number of end-to-end (E2E) tests. The pyramid shape illustrates the proportion of each type of test you should aim for in your test suite, usually it is <strong>50% unit tests, 30% integration tests,</strong> and <strong>20% end-to-end (E2E) tests</strong></p><h2 id="ðŸ“‘-the-layers-of-the-testing-pyramid" tabindex="-1">ðŸ“‘ <strong>The Layers of the Testing Pyramid</strong> <a class="header-anchor" href="#ðŸ“‘-the-layers-of-the-testing-pyramid" aria-label="Permalink to &quot;ðŸ“‘ **The Layers of the Testing Pyramid**&quot;">â€‹</a></h2><ol><li><p><strong>Unit Tests (Base of the Pyramid)</strong></p><ul><li><strong>What</strong>: Tests individual components or units of code in isolation.</li><li><strong>Why</strong>: They are fast, reliable, and help catch bugs early in the development process.</li><li><strong>How Many</strong>: You should have the most unit tests because they are cheap to write and maintain.</li></ul></li><li><p><strong>Integration Tests (Middle Layer)</strong></p><ul><li><strong>What</strong>: Tests how multiple units or components work together.</li><li><strong>Why</strong>: Ensures that different parts of the system interact correctly.</li><li><strong>How Many</strong>: Fewer than unit tests but more than E2E tests.</li></ul></li><li><p><strong>End-to-End (E2E) Tests (Top of the Pyramid)</strong></p><ul><li><strong>What</strong>: Tests the entire application workflow from start to finish, simulating real user scenarios.</li><li><strong>Why</strong>: Ensures the system works as a whole and meets user expectations.</li><li><strong>How Many</strong>: The fewest in number because they are slow, expensive to write, and harder to maintain.</li><li><strong>Example</strong>: Testing the workflow of adding a superhero to a team via an API.</li></ul></li></ol><h2 id="ðŸ’­-why-the-testing-pyramid-works" tabindex="-1">ðŸ’­ <strong>Why the Testing Pyramid Works</strong> <a class="header-anchor" href="#ðŸ’­-why-the-testing-pyramid-works" aria-label="Permalink to &quot;ðŸ’­ **Why the Testing Pyramid Works**&quot;">â€‹</a></h2><ol><li><strong>Speed</strong>: Unit tests are fast and can be run frequently during development.</li><li><strong>Reliability</strong>: Unit tests are less flaky because they test small, isolated pieces of code.</li><li><strong>Cost</strong>: Unit tests are cheaper to write and maintain compared to integration and E2E tests.</li><li><strong>Coverage</strong>: Unit tests provide broad coverage of the codebase, while integration and E2E tests ensure the system works as a whole.</li></ol><hr><p><img src="'+n+'" alt="Testing Pyramid image"></p><p>The higher up you go in the pyramid, the more brittle and less predictable your tests are. What&#39;s more, e2e tests are by far the slowest to run so even though they can bring confidence that your application is doing what&#39;s expected of it, you shouldn&#39;t have nearly as many of them as unit or integration tests.</p>',9)]))}const u=e(r,[["render",i]]);export{y as __pageData,u as default};
